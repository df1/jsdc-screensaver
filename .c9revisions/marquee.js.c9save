{"ts":1365849089873,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1365849097622,"patch":[[{"diffs":[[1,"/**\n* author Remy Sharp\n* url http://remysharp.com/tag/marquee\n*/\n\n(function ($) {\n    $.fn.marquee = function (klass) {\n        var newMarquee = [],\n            last = this.length;\n\n        // works out the left or right hand reset position, based on scroll\n        // behavior, current direction and new direction\n        function getReset(newDir, marqueeRedux, marqueeState) {\n            var behavior = marqueeState.behavior, width = marqueeState.width, dir = marqueeState.dir;\n            var r = 0;\n            if (behavior == 'alternate') {\n                r = newDir == 1 ? marqueeRedux[marqueeState.widthAxis] - (width*2) : width;\n            } else if (behavior == 'slide') {\n                if (newDir == -1) {\n                    r = dir == -1 ? marqueeRedux[marqueeState.widthAxis] : width;\n                } else {\n                    r = dir == -1 ? marqueeRedux[marqueeState.widthAxis] - (width*2) : 0;\n                }\n            } else {\n                r = newDir == -1 ? marqueeRedux[marqueeState.widthAxis] : 0;\n            }\n            return r;\n        }\n\n        // single \"thread\" animation\n        function animateMarquee() {\n            var i = newMarquee.length,\n                marqueeRedux = null,\n                $marqueeRedux = null,\n                marqueeState = {},\n                newMarqueeList = [],\n                hitedge = false;\n                \n            while (i--) {\n                marqueeRedux = newMarquee[i];\n                $marqueeRedux = $(marqueeRedux);\n                marqueeState = $marqueeRedux.data('marqueeState');\n                \n                if ($marqueeRedux.data('paused') !== true) {\n                    // TODO read scrollamount, dir, behavior, loops and last from data\n                    marqueeRedux[marqueeState.axis] += (marqueeState.scrollamount * marqueeState.dir);\n\n                    // only true if it's hit the end\n                    hitedge = marqueeState.dir == -1 ? marqueeRedux[marqueeState.axis] <= getReset(marqueeState.dir * -1, marqueeRedux, marqueeState) : marqueeRedux[marqueeState.axis] >= getReset(marqueeState.dir * -1, marqueeRedux, marqueeState);\n                    \n                    if ((marqueeState.behavior == 'scroll' && marqueeState.last == marqueeRedux[marqueeState.axis]) || (marqueeState.behavior == 'alternate' && hitedge && marqueeState.last != -1) || (marqueeState.behavior == 'slide' && hitedge && marqueeState.last != -1)) {                        \n                        if (marqueeState.behavior == 'alternate') {\n                            marqueeState.dir *= -1; // flip\n                        }\n                        marqueeState.last = -1;\n\n                        $marqueeRedux.trigger('stop');\n\n                        marqueeState.loops--;\n                        if (marqueeState.loops === 0) {\n                            if (marqueeState.behavior != 'slide') {\n                                marqueeRedux[marqueeState.axis] = getReset(marqueeState.dir, marqueeRedux, marqueeState);\n                            } else {\n                                // corrects the position\n                                marqueeRedux[marqueeState.axis] = getReset(marqueeState.dir * -1, marqueeRedux, marqueeState);\n                            }\n\n                            $marqueeRedux.trigger('end');\n                        } else {\n                            // keep this marquee going\n                            newMarqueeList.push(marqueeRedux);\n                            $marqueeRedux.trigger('start');\n                            marqueeRedux[marqueeState.axis] = getReset(marqueeState.dir, marqueeRedux, marqueeState);\n                        }\n                    } else {\n                        newMarqueeList.push(marqueeRedux);\n                    }\n                    marqueeState.last = marqueeRedux[marqueeState.axis];\n\n                    // store updated state only if we ran an animation\n                    $marqueeRedux.data('marqueeState', marqueeState);\n                } else {\n                    // even though it's paused, keep it in the list\n                    newMarqueeList.push(marqueeRedux);                    \n                }\n            }\n\n            newMarquee = newMarqueeList;\n            \n            if (newMarquee.length) {\n                setTimeout(animateMarquee, 15);\n            }            \n        }\n        \n        // TODO consider whether using .html() in the wrapping process could lead to loosing predefined events...\n        this.each(function (i) {\n            var $marquee = $(this),\n                width = $marquee.attr('width') || $marquee.width(),\n                height = $marquee.attr('height') || $marquee.height(),\n                $marqueeRedux = $marquee.after('<div ' + (klass ? 'class=\"' + klass + '\" ' : '') + 'style=\"display: block-inline; width: ' + width + 'px; height: ' + height + 'px; overflow: hidden;\"><div style=\"float: left; white-space: nowrap;\">' + $marquee.html() + '</div></div>').next(),\n                marqueeRedux = $marqueeRedux.get(0),\n                hitedge = 0,\n                direction = ($marquee.attr('direction') || 'left').toLowerCase(),\n                marqueeState = {\n                    dir : /down|right/.test(direction) ? -1 : 1,\n                    axis : /left|right/.test(direction) ? 'scrollLeft' : 'scrollTop',\n                    widthAxis : /left|right/.test(direction) ? 'scrollWidth' : 'scrollHeight',\n                    last : -1,\n                    loops : $marquee.attr('loop') || -1,\n                    scrollamount : $marquee.attr('scrollamount') || this.scrollAmount || 2,\n                    behavior : ($marquee.attr('behavior') || 'scroll').toLowerCase(),\n                    width : /left|right/.test(direction) ? width : height\n                };\n            \n            // corrects a bug in Firefox - the default loops for slide is -1\n            if ($marquee.attr('loop') == -1 && marqueeState.behavior == 'slide') {\n                marqueeState.loops = 1;\n            }\n\n            $marquee.remove();\n            \n            // add padding\n            if (/left|right/.test(direction)) {\n                $marqueeRedux.find('> div').css('padding', '0 ' + width + 'px');\n            } else {\n                $marqueeRedux.find('> div').css('padding', height + 'px 0');\n            }\n            \n            // events\n            $marqueeRedux.bind('stop', function () {\n                $marqueeRedux.data('paused', true);\n            }).bind('pause', function () {\n                $marqueeRedux.data('paused', true);\n            }).bind('start', function () {\n                $marqueeRedux.data('paused', false);\n            }).bind('unpause', function () {\n                $marqueeRedux.data('paused', false);\n            }).data('marqueeState', marqueeState); // finally: store the state\n            \n            // todo - rerender event allowing us to do an ajax hit and redraw the marquee\n\n            newMarquee.push(marqueeRedux);\n\n            marqueeRedux[marqueeState.axis] = getReset(marqueeState.dir, marqueeRedux, marqueeState);\n            $marqueeRedux.trigger('start');\n            \n            // on the very last marquee, trigger the animation\n            if (i+1 == last) {\n                animateMarquee();\n            }\n        });            \n\n        return $(newMarquee);\n    };\n}(jQuery));"]],"start1":0,"start2":0,"length1":0,"length2":7381}]],"length":7381,"saved":false}
{"contributors":[],"silentsave":false,"ts":1365849181571,"patch":[[{"diffs":[[0,"arquee, "],[-1,"1"],[0,"5);\n    "]],"start1":4337,"start2":4337,"length1":17,"length2":16}]],"length":7380,"saved":false}
